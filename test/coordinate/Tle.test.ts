import { ClassicalElements, EpochUTC, Kilometers, Radians, Tle, TleLine1, TleLine2 } from '../../src/main';

describe('Tle', () => {
  let tle: Tle;
  let exampleDate: Date;

  beforeEach(() => {
    // Sample TLE
    const tle1 = '1 56006U 23042W   24012.45049317  .00000296  00000-0  36967-4 0  9992' as TleLine1;
    const tle2 = '2 56006 143.0043  13.3620 0001137 267.5965  92.4747 15.02542972 44491' as TleLine2;
    const mockExampleDate = new Date(1705109326817);

    exampleDate = new Date(mockExampleDate.getTime());
    tle = new Tle(tle1, tle2);
  });

  // toString
  it('should return the TLE as a string', () => {
    expect(tle.toString()).toMatchSnapshot();
  });

  // semiMajorAxis
  it('should return the semi-major axis', () => {
    expect(tle.semimajorAxis).toMatchSnapshot();
  });

  // eccentricity
  it('should return the eccentricity', () => {
    expect(tle.eccentricity).toMatchSnapshot();
  });

  // inclination
  it('should return the inclination', () => {
    expect(tle.inclination).toMatchSnapshot();
  });

  // inclinationDeg
  it('should return the inclination in degrees', () => {
    expect(tle.inclinationDegrees).toMatchSnapshot();
  });

  // apogee
  it('should return the apogee', () => {
    expect(tle.apogee).toMatchSnapshot();
  });

  // perigee
  it('should return the perigee', () => {
    expect(tle.perigee).toMatchSnapshot();
  });

  // period
  it('should return the period', () => {
    expect(tle.period).toMatchSnapshot();
  });

  // propagate
  it('should propagate the TLE', () => {
    const epoch = EpochUTC.fromDateTime(exampleDate);
    const propagated = tle.propagate(epoch);

    expect(propagated).toMatchSnapshot();
  });

  // state
  it('should return the state vector', () => {
    expect(tle.state).toMatchSnapshot();
  });

  // fromClassicalElements
  it('should create a TLE from classical orbital elements', () => {
    const epoch = EpochUTC.fromDateTime(exampleDate);
    const elements = new ClassicalElements({
      epoch,
      semimajorAxis: 6943.547853722985 as Kilometers,
      eccentricity: 0.0011235968124658146,
      inclination: 0.7509087232045765 as Radians,
      rightAscension: 0.028239555738616327 as Radians,
      argPerigee: 2.5386411901807353 as Radians,
      trueAnomaly: 0.5931399364974058 as Radians,
    });
    const tle = Tle.fromClassicalElements(elements);

    expect(tle).toMatchSnapshot();
  });
});

// Generated by Qodo Gen

describe('convert6DigitToA5', () => {

  // Converts a 6-digit SCC number to a 5-digit Alpha-5 format by replacing first two digits with a letter
  it('should convert 6-digit SCC number to Alpha-5 format', () => {
    // Test cases with different first two digits
    expect(Tle.convert6DigitToA5('123456')).toBe('C3456');
    expect(Tle.convert6DigitToA5('183456')).toBe('J3456');
    expect(Tle.convert6DigitToA5('243456')).toBe('Q3456');
    expect(Tle.convert6DigitToA5('333456')).toBe('Z3456');
  });

  // Handles inputs with exactly 6 characters
  it('should return original input when not a 6-digit number or already Alpha-5', () => {
    // Less than 6 digits
    expect(Tle.convert6DigitToA5('12345')).toBe('12345');

    // Already Alpha-5 format
    expect(Tle.convert6DigitToA5('A2345')).toBe('A2345');
    expect(Tle.convert6DigitToA5('Z2345')).toBe('Z2345');

    // Edge case - exactly 6 characters but first is already a letter
    expect(Tle.convert6DigitToA5('B12345')).toBe('B12345');
  });
});

// Generated by Qodo Gen

describe('parseAll', () => {

  // Successfully parses both TLE lines and combines them into a single data object
  it('should combine data from both TLE lines into a single object', () => {
    const tleLine1 = '1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927' as TleLine1;
    const tleLine2 = '2 25544 051.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537' as TleLine2;

    const result = Tle.parseAll(tleLine1, tleLine2);

    expect(result.satNum).toBe(25544);
    expect(result.lineNumber1).toBe(1);
    expect(result.lineNumber2).toBe(2);
    expect(result.inclination).toBeCloseTo(51.6416);
    expect(result.rightAscension).toBeCloseTo(247.4627);
    expect(result.eccentricity).toBeCloseTo(0.0006703);
    expect(result.intlDes).toBe('1998-067A');
    expect(result.epochYear).toBe(8);
    expect(result.epochDay).toBeCloseTo(264.51782528);
    expect(result.meanMotion).toBeCloseTo(15.72125391);
  });

  // Throws error when satellite numbers don't match between lines
  it('should throw error when satellite numbers do not match between lines', () => {
    const tleLine1 = '1 25544U 98067A   08264.51782528 -.00002182  00000-0 -11606-4 0  2927' as TleLine1;
    const tleLine2 = '2 25545 051.6416 247.4627 0006703 130.5360 325.0288 15.72125391563537' as TleLine2;

    expect(() => {
      Tle.parseAll(tleLine1, tleLine2);
    }).toThrow('Satellite numbers do not match');
  });
});

// Generated by Qodo Gen

describe('parse', () => {

  // Successfully parses valid TLE lines and returns TleData object with orbital parameters
  it('should return a valid TleData object when given correct TLE lines', () => {
    const line1 = '1 25544U 98067A   20049.59954503  .00001714  00000-0  38792-4 0  9993' as TleLine1;
    const line2 = '2 25544  51.6454 207.5396 0005246  10.7845 349.3392 15.49172904214789' as TleLine2;

    const result = Tle.parse(line1, line2);

    expect(result).toBeDefined();
    expect(result.satNum).toBe(25544);
    expect(result.intlDes).toBe('1998-067A');
    expect(result.epochYear).toBe(20);
    expect(result.epochDay).toBe(49.59954503);
    expect(result.meanMoDev1).toBe(0.00001714);
    expect(result.bstar).toBeCloseTo(0.00003879, 8);
    expect(result.inclination).toBeCloseTo(51.6454, 4);
    expect(result.rightAscension).toBeCloseTo(207.5396, 4);
    expect(result.eccentricity).toBeCloseTo(0.0005246, 7);
    expect(result.argOfPerigee).toBeCloseTo(10.7845, 4);
    expect(result.meanAnomaly).toBeCloseTo(349.3392, 4);
    expect(result.meanMotion).toBeCloseTo(15.49172904, 8);
    expect(result.period).toBeCloseTo(92.95, 2);
  });

  // Throws error when satellite numbers don't match between line 1 and line 2
  it('should throw an error when satellite numbers don\'t match between lines', () => {
    const line1 = '1 25544U 98067A   20049.59954503  .00001714  00000-0  38792-4 0  9993' as TleLine1;
    const line2 = '2 25545  51.6454 207.5396 0005246  10.7845 349.3392 15.49172904214789' as TleLine2;

    expect(() => {
      Tle.parse(line1, line2);
    }).toThrow('Satellite numbers do not match');
  });
});
