import { Earth, EpochUTC, ITRF, Kilometers, KilometersPerSecond, Vector3D } from './../../src/main';
// Generated by CodiumAI

describe('ITRF', () => {
  let epochUtc: EpochUTC;
  let exampleDate: Date;
  let itrf: ITRF;

  beforeEach(() => {
    const mockExampleDate = new Date(1705109326817);

    exampleDate = new Date(mockExampleDate.getTime());
    epochUtc = EpochUTC.fromDateTime(mockExampleDate);
    itrf = new ITRF(
      epochUtc,
      new Vector3D<Kilometers>(1000 as Kilometers, 2000 as Kilometers, 3000 as Kilometers),
      new Vector3D(10 as KilometersPerSecond, 20 as KilometersPerSecond, 30 as KilometersPerSecond),
    );
  });

  // can get the name of the ITRF coordinate system
  it('should return the name of the coordinate system', () => {
    expect(itrf.name).toMatchSnapshot();
  });

  // can determine if the coordinate system is inertial
  it('should return whether the coordinate system is inertial', () => {
    expect(itrf.inertial).toMatchSnapshot();
  });

  /*
   * can get the height of the ITRF coordinate above the surface of the Earth in
   * kilometers
   */
  it('should return the height above the surface of the Earth in kilometers', () => {
    expect(itrf.height).toMatchSnapshot();
  });

  // can get the altitude in kilometers
  it('should return the altitude in kilometers', () => {
    expect(itrf.alt).toMatchSnapshot();
  });

  // can convert the current coordinate to the J2000 coordinate system
  it('should convert the current coordinate to the J2000 coordinate system', () => {
    expect(itrf.toJ2000()).toMatchSnapshot();
  });

  // can convert the current ITRF coordinate to Geodetic coordinate
  it('should convert the current ITRF coordinate to Geodetic coordinate', () => {
    expect(itrf.toGeodetic()).toMatchSnapshot();
  });

  // can handle position at the center of the Earth
  it('should handle position at the center of the Earth', () => {
    itrf = new ITRF(
      epochUtc,
      new Vector3D<Kilometers>(0 as Kilometers, 0 as Kilometers, 0 as Kilometers),
      new Vector3D(0 as KilometersPerSecond, 0 as KilometersPerSecond, 0 as KilometersPerSecond),
    );
    expect(itrf.toJ2000()).toMatchSnapshot();
  });

  // can handle position at the North Pole
  it('should handle position at the North Pole', () => {
    const itrf = new ITRF(
      epochUtc,
      new Vector3D<Kilometers>(0 as Kilometers, 0 as Kilometers, Earth.radiusPolar),
      new Vector3D(0 as KilometersPerSecond, 0 as KilometersPerSecond, 0 as KilometersPerSecond),
    );

    expect(itrf.toJ2000()).toMatchSnapshot();
    // Test the toGeodetic method
    expect(itrf.toGeodetic()).toMatchSnapshot();
  });

  // can handle position at the South Pole
  it('should handle position at the South Pole', () => {
    const itrf = new ITRF(
      epochUtc,
      new Vector3D<Kilometers>(0 as Kilometers, 0 as Kilometers, -Earth.radiusPolar as Kilometers),
      new Vector3D(0 as KilometersPerSecond, 0 as KilometersPerSecond, 0 as KilometersPerSecond),
    );

    itrf.position = new Vector3D<Kilometers>(0 as Kilometers, 0 as Kilometers, -Earth.radiusPolar as Kilometers);
    expect(itrf.toJ2000()).toMatchSnapshot();
    // Test the toGeodetic method
    expect(itrf.toGeodetic()).toMatchSnapshot();
  });

  // can handle position at the International Date Line
  it('should handle position at the International Date Line', () => {
    const itrf = new ITRF(
      epochUtc,
      new Vector3D<Kilometers>(Earth.radiusEquator, 0 as Kilometers, 0 as Kilometers),
      new Vector3D(0 as KilometersPerSecond, 0 as KilometersPerSecond, 0 as KilometersPerSecond),
    );

    // Test height
    expect(itrf.height).toMatchSnapshot();

    // Test alt
    expect(itrf.alt).toMatchSnapshot();

    // Test toJ2000
    expect(itrf.toJ2000()).toMatchSnapshot();

    // Test toGeodetic
    expect(itrf.toGeodetic()).toMatchSnapshot();
  });

  // can handle position at the Prime Meridian
  it('should handle position at the Prime Meridian', () => {
    const itrf = new ITRF(
      epochUtc,
      new Vector3D<Kilometers>(0 as Kilometers, Earth.radiusEquator, 0 as Kilometers),
      new Vector3D(0 as KilometersPerSecond, 0 as KilometersPerSecond, 0 as KilometersPerSecond),
    );

    expect(itrf.name).toMatchSnapshot();
    expect(itrf.inertial).toMatchSnapshot();
    expect(itrf.height).toMatchSnapshot();
    expect(itrf.alt).toMatchSnapshot();
    expect(itrf.toJ2000()).toMatchSnapshot();
    expect(itrf.toGeodetic()).toMatchSnapshot();
  });

  // can handle position at high altitude
  it('should handle position at high altitude', () => {
    const itrf = new ITRF(
      epochUtc,
      new Vector3D<Kilometers>(0 as Kilometers, (Earth.radiusEquator + 1000) as Kilometers, 0 as Kilometers),
      new Vector3D(0 as KilometersPerSecond, 0 as KilometersPerSecond, 0 as KilometersPerSecond),
    );

    expect(itrf.height).toMatchSnapshot();
    expect(itrf.alt).toMatchSnapshot();
    expect(itrf.toJ2000()).toMatchSnapshot();
    expect(itrf.toGeodetic()).toMatchSnapshot();
  });

  // can handle position at low altitude
  it('should handle position at low altitude', () => {
    const itrf = new ITRF(
      epochUtc,
      new Vector3D<Kilometers>(0 as Kilometers, (Earth.radiusEquator - 10) as Kilometers, 0 as Kilometers),
      new Vector3D(0 as KilometersPerSecond, 0 as KilometersPerSecond, 0 as KilometersPerSecond),
    );

    expect(itrf.height).toMatchSnapshot();
    expect(itrf.alt).toMatchSnapshot();
    expect(itrf.toJ2000()).toMatchSnapshot();
    expect(itrf.toGeodetic()).toMatchSnapshot();
  });

  // can handle position at the antimeridian
  it('should handle position at the antimeridian', () => {
    const itrf = new ITRF(
      epochUtc,
      new Vector3D(0 as Kilometers, 0 as Kilometers, Earth.radiusEquator),
      new Vector3D(0 as KilometersPerSecond, 0 as KilometersPerSecond, 0 as KilometersPerSecond),
    );

    // Test the height property
    expect(itrf.height).toMatchSnapshot();

    // Test the alt property
    expect(itrf.alt).toMatchSnapshot();

    // Test the toJ2000 method
    expect(itrf.toJ2000()).toMatchSnapshot();

    // Test the toGeodetic method
    expect(() => itrf.toGeodetic()).toMatchSnapshot();
  });

  // can handle position at the equator
  it('should handle position at the equator with negative y-coordinate', () => {
    const itrf = new ITRF(
      epochUtc,
      new Vector3D<Kilometers>(0 as Kilometers, -Earth.radiusEquator as Kilometers, 0 as Kilometers),
      new Vector3D(0 as KilometersPerSecond, 0 as KilometersPerSecond, 0 as KilometersPerSecond),
    );

    expect(itrf.name).toMatchSnapshot();
    expect(itrf.inertial).toMatchSnapshot();
    expect(itrf.height).toMatchSnapshot();
    expect(itrf.alt).toMatchSnapshot();
    expect(itrf.toJ2000()).toMatchSnapshot();
    expect(itrf.toGeodetic()).toMatchSnapshot();
  });

  // can handle position at different epochs
  it('should handle position at different epochs', () => {
    const position = new Vector3D<Kilometers>(1000 as Kilometers, 2000 as Kilometers, 3000 as Kilometers);
    const velocity = new Vector3D(10 as KilometersPerSecond, 20 as KilometersPerSecond, 30 as KilometersPerSecond);
    const epoch1 = EpochUTC.fromDateTime(exampleDate);
    const epoch2 = EpochUTC.fromDateTime(new Date(exampleDate.getTime() + 1000));
    const itrf1 = new ITRF(epoch1, position, velocity);
    const itrf2 = new ITRF(epoch2, position, velocity);

    // Test height property
    expect(itrf1.height).toMatchSnapshot();
    expect(itrf2.height).toMatchSnapshot();

    // Test alt property
    expect(itrf1.alt).toMatchSnapshot();
    expect(itrf2.alt).toMatchSnapshot();

    // Test toJ2000 method
    const j2000 = itrf1.toJ2000();

    expect(j2000).toMatchSnapshot();

    // Test toGeodetic method
    const geodetic = itrf1.toGeodetic();

    expect(geodetic).toMatchSnapshot();
  });

  // toClassicalElements
  it('should return classical elements', () => {
    const itrf = new ITRF(
      epochUtc,
      new Vector3D<Kilometers>(1000 as Kilometers, 2000 as Kilometers, 3000 as Kilometers),
      new Vector3D(10 as KilometersPerSecond, 20 as KilometersPerSecond, 30 as KilometersPerSecond),
    );

    expect(() => itrf.toClassicalElements()).toThrow();
  });
});
