/**
 * @author Theodore Kruczek.
 * @description Orbital Object ToolKit (OOTK) is a collection of tools for working
 * with satellites and other orbital objects.
 *
 * @file The Multi module is meant to enable parallel calculations across multiple
 * threads. This will drastically increase performance for large number of
 * calculations.
 *
 * @copyright MIT License.
 * Copyright (c) 2020-2021 Theodore Kruczek
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/** @interface SatelliteRecord contains all of the orbital parameters necessary for running SGP4. It is generated by Sgp4.createSatrec.*/
interface SatelliteRecord {
  a: number;
  am: number;
  alta: number;
  altp: number;
  argpdot: number;
  argpo: number;
  aycof: number;
  bstar: number;
  cc1: number;
  cc4: number;
  cc5: number;
  con41: number;
  d2: number;
  d3: number;
  d4: number;
  d5232: number;
  d5421: number;
  d5433: number;
  dedt: number;
  delmo: number;
  del1: number;
  ecco: number;
  em: number;
  epochdays: number;
  epochyr: number;
  error: number;
  eta: number;
  gsto: number;
  im: number;
  inclo: number;
  init: string;
  isimp: number;
  jdsatepoch: number;
  mdot: number;
  method: string;
  mo: number;
  mm: number;
  nddot: number;
  ndot: number;
  no: number;
  nodecf: number;
  nodedot: number;
  nodeo: number;
  om: number;
  Om: number;
  omgcof: number;
  operationmode: string;
  satnum: string;
  sinmao: number;
  t: number;
  t2cof: number;
  t3cof: number;
  t4cof: number;
  t5cof: number;
  x1mth2: number;
  x7thm1: number;
  xlcof: number;
  xmcof: number;
  xfact: number;
  xlamo: number;
  xli: number;
  xgh4: number;
  xgh3: number;
  xh2: number;
  xi2: number;
  xi3: number;
  xl2: number;
  xl3: number;
  xl4: number;
  zmol: number;
  zmos: number;
  dmdt: number;
  dnodt: number;
  domdt: number;
  e3: number;
  ee2: number;
  peo: number;
  pgho: number;
  pho: number;
  PInco: number;
  plo: number;
  se2: number;
  se3: number;
  sgh2: number;
  sgh3: number;
  sgh4: number;
  sh2: number;
  sh3: number;
  si2: number;
  si3: number;
  sl2: number;
  sl3: number;
  sl4: number;
  xgh2: number;
  xh3: number;
  tumin: number;
  radiusearthkm: number;
  irez: number;
  d3210: number;
  d3222: number;
  d4410: number;
  d4422: number;
  d5220: number;
  del2: number;
  del3: number;
  didt: number;
  atime: number;
  j2: number;
  j3: number;
  j4: number;
  mus: number;
  xke: number;
  j3oj2: number;
  xni: number;
  d2201: number;
  d2211: number;
  nm: number;
}

class Multi {
  threads = 0;
  thread = [];
  encoderInst = null;
  decoderInst = null;

  constructor(threads: number) {
    this.encoderInst = new TextEncoder();
    this.decoderInst = new TextDecoder();
    this.threads = threads;
    for (let index = 0; index < this.threads; index++) {
      this.thread[index] = new Worker('./dist/ootk-multi.worker.js');
    }
  }

  public propagate(satrecs: SatelliteRecord[], times: number[]) {
    return this._propagate(satrecs, times).then((results) => {
      const returnArray = new Float32Array(satrecs.length * times.length * 7);
      let offset = 0;
      for (let index = 0; index < this.threads; index++) {
        const dataArray = new Float32Array(results[index].data);
        returnArray.set(dataArray,offset);
        offset += dataArray.length;
      }
      return returnArray;
    });
  }

  private async _propagate(satrecs: SatelliteRecord[], times: number[]): Promise<any> {
    const tasks = Multi.chunkArray2(satrecs, this.threads);
    const results = [];

    for (let index = 0; index < this.threads; index++) {
      const whichWorker = this.thread[index];
      const taskBuffer = this.encoderInst.encode(JSON.stringify({ type: 'propagate', tasks: tasks[index], times: times })).buffer;
      results.push(this.createTasks(whichWorker, taskBuffer));
    }

    return Promise.all(results).then((data) => data);
  }

  // eslint-disable-next-line class-methods-use-this
  private createTasks(whichWorker: Worker, taskBuffer): Promise<any> {
    return new Promise((resolve, reject) => {
      whichWorker.postMessage(taskBuffer,[taskBuffer]);
      whichWorker.onmessage = (m) => {        
        resolve(m);
        // whichWorker.terminate();
      };
      whichWorker.onerror = (m) => {
        console.log(m);
        reject;
      };
    });
  }

  private static chunkArray2(sourceArr: SatelliteRecord[], chunks: number): SatelliteRecord[][] {
    const lengthOfArray = sourceArr.length;
    const chunkSize = Math.floor(lengthOfArray / chunks);
    const result = [];

    let i = 0;
    while (i < lengthOfArray) {
      result.push(sourceArr.slice(i, (i += chunkSize)));
    }

    return result;
  }

  private static chunkArray(sourceArr: SatelliteRecord[], chunks: number): SatelliteRecord[][] {
    const lengthOfArray = sourceArr.length;
    const result = Array.from(Array(chunks), () => []);

    for (let index = 0; index < lengthOfArray; index++) {
      result[index % chunks].push(sourceArr[index]);
    }
    return result;
  }
}

export { Multi };
